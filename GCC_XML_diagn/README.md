# Материал по работе над проектом GCC XML diagnostics
## Полезные ссылки
- [Официальный сайт](https://gcc.gnu.org/) GCC
- Раздел [С чего начать"](https://gcc.gnu.org/wiki/GettingStarted) в GCC wiki
упоминает 10 простых шагов (помимо собственно решения задачи :)):
 1. Подписать договор о передаче исключительного права. Мы займёмся этим как
    только будет готов патч пригодный для того, чтобы отправить его на ревью
    сообществу разработчиков.
 2. Настроить [git](https://gcc.gnu.org/wiki/GitMirror). Subversion - не наш
    вариант.
 3. Научиться [собирать](https://gcc.gnu.org/wiki/InstallingGCC) GCC из
    исходников.
 4. Научиться [тестировать](https://gcc.gnu.org/wiki/Testing_GCC) GCC
 5. Научиться [отлаживать](https://gcc.gnu.org/wiki/DebuggingGCC) GCC
 6. Подписаться на [списки рассылки](https://gcc.gnu.org/lists.html) gcc и
    gcc-patches, присоединиться тем самым к [сообществу
    разработчиков](https://gcc.gnu.org/wiki/Community).
 7. Правильно [настроить](https://gcc.gnu.org/wiki/FormattingCodeForGCC)
    редактор кода
 8. Сформировать патч и отправить его в рассылку
 9. Начать коммитить патчи самостоятельно (всё ещё впереди ;))
 10. Profit!
- [Видео](http://www.cse.iitb.ac.in/grc/index.php?page=videos) курса "Essential
abstractions in GCC". Имеются подводные грабли:
 - Видео записано в 2012 году (на сайте есть
   [слайды](http://www.cse.iitb.ac.in/grc/gcc-workshop-13/index.php?page=slides) с
   обновлением от 2013 года). Используется версия GCC 4.6.x, которая
   существенно отличается от текущей (как минимум, сейчас компилятор
   разрабатывается на языке C++, а не C).
 - Много внимания уделено бэкенду (оптимизаторам, генерации кода), а не
   фронтэнду (разбору исходного кода). Нам предстоит работать преимущественно с
   фронтэндом.
 - Большая часть полезных для нас материалов - это части 1 - 4.
- Справочное [Руководство](https://gcc.gnu.org/onlinedocs/gccint/) по
  внутреннему устройству GCC. Достаточно подробное. Стоит проглядеть разделы
  посвящённые структуре директорий и процессу сборки.

## С чего начать

### Работа с репозиторием, сборка и тестирование

Пропробуйте сделать следующее:

- Сделать git clone официальной репы GCC (не путайте с зеркалом на github)
- Установить на компьютер все инструменты, необходимые для сборки и прогона
  тестов GCC (см. ссылку выше). Разобраться, как происходит процесс сборки (в
  общих чертах). Научиться конфигурировать и собирать GCC в простейшем варианте
  (без дополнительных настроек configure)
- Небольшой подводный камень: GCC использует библиотеки MPC, MPFR, GMP и ISL.
  Проще всего скачать при помощи скрипта `src/contrib/download-prerequisites` - По
  умолчанию GCC компилируется в режиме multilib, т.е. runtime-библиотеки (такие
  как стандартная библиотека C++) компилируются также для i386, соответственно
  может потребоваться наличие в системе бибилиотек (glibc и других) для i386.
  Отключить этот режим можно с помощью configure-опции `--disable-multilib` Не
  забудьте про параметр `-j` (кол-во параллельных процессов) у команды make!

#### Варианты сборки GCC

Научитесь собирать компилятор в некоторых других вариантах (это сильно ускорит
процесс сборки!). Попробуйте сделать следующее:

- Включить поддержку только языков C и C++ (ключ `--enable-languages` скрипте
`configure`)
- Отключить bootstrap (`--disable-bootrap`)
- Отключить multilib (`--disable-multilib`, если ещё не сделали на прошлом шаге)
- Отключить поддержку локализации (`--disable-nls`)

Далее:

- Соберите GCC без оптимизации и с отладочной информацией (-O0, -ggdb3), см.
  [Building a Debuggable Compiler](https://gcc.gnu.org/wiki/DebuggingGCC#gccbuilddebug) в wiki.
  Этот вариант может потребоваться при отладке.

#### Инкрементальная сборка

Научитесь собирать компилятор инкрементально, т.е. так чтобы при изменении
одного файла пересобирался только этот файл (см. раздел
[Top-Level_Bootstrap](https://gcc.gnu.org/wiki/Top-Level_Bootstrap), команда
`make stage1-bubble`), настройте такую сборку в своём редакторе кода.

#### Запуск тестов

Посмотрите (эта информация пригодится в будущем), где (и какие) тесты находятся
в дереве исходников.

Попбуйте сделать следующее:
- Запустить тесты (не забывайте про `make -j...`!), дождаться результатов их
  выполнения. Не пугайтесь, если некоторая часть тестов завершается неудачно.
- Научиться сравнивать результаты тестов. Представьте, что вы внесли измнение в
  компилятор. Как бы вы проверили, что в результате него не произошло регресии
  (т.е. все тесты, которые успешно завершались ранее, по-прежнему завершаются
  успешно)? В директории `contrib` есть несколько полезных скриптов.
- Научиться прогонять отдельные тесты. Выберите один (любой) файл с тестами,
  проверяющими вывод диагностики и запустите его.

### Подсистема диагностики

Я составил несколько простых тестовых примеров с разными диагностическими
сообщениями, чтобы вам было проще начать работать. Все примеры находятся в
директории `examples`. Для их компиляции необходимо в файле `test.sh` указать
путь к директории, в которой производилась сборка GCC и запустить этот файл

Обратите внимание, что компилятор запускается в обход драйвера (т.е. `cc1`
вместо `gcc`). Именно так проще всего будет запускать компилятор под отладчиком
(если это потребуется).

- `simple.c` - простой пример с одной ошибкой
- `include.c`, `header1.h`, `header2.h` - в этом примере ошибка возникает в
   заголовочном файле
- `include.i` - этот файл получен из трёх предыдущих при помощи препроцессора:
  `gcc -E include.c -o include.i`, должен давать результат эквивалентный
  `include.c`
- `printf.c` - в предупреждении выводятся несколько типов данных (`double`,
  `int`) и строка (`'%f'`).
- `macro.c` - пример, в котором ошибка в коде, полученном при подстановке
  макроса (macro expansion).
- `indent.c` - пример нового предупреждения, `-Wmisleading-indentation`. Этот
  пример может оказаться нетривиальным с точки зрения разрабатываемого формата.
  Следуют иметь его в виду.
- `overload.cc` - в отличие от всех предыдущих программ, эта написана на C++.
  Здесь ошибка состоит в том, что объявлено две перегрузки функции foo и вызов
  неоднозначен. Компилятор выводит список функций-кандидатов.
- `template.cc` - этот тот самый пример из письма, которое я вам отправлял.
  Ошибка по сути та же, что и в прошлом примере: неоднозначный вызов функции с
  несколькими перегрузками. Отличия в следующем:
 - перегруженные функции определяются при помощи макроса и компилятор выводит
   соответствующее примечание
 - неоднозначный вызов происходит при инстанцировании шаблонного класса adder
   который в свою очередь вызывает constexpr-функцию add_val (чтобы
   проиницилизаровать статическую constexpr-переменную value). Всю эту цепочку мы
   видим в сообщении об ошибке
 - сообщение "constexpr call flows off the end of the function" - это в
   некоторой степени проблема компилятора. Он не способен корректно продолжить
   разбор программы после реальной ошибки "call of overloaded 'add_overload(int&)'
   is ambiguous".
- `test.f95` - программа на языке Fortran. Обратите внимание, что здесь немного
  отличается внешний вид диагностики.

#### libcpp, позиции в файлах

В директории `libcpp` (не путать с фронтэндом языка C++, `gcc/cp`) находится
препроцессор - часть компилятора, отвечающая за обработку таких конструкций
языка, как включаемые файлы (include) и макросы.

Именно libcpp отвечает за информацию о позициях лексем в исходном коде. Работа с
этой информацией нетривиальна т.к. для каждой лексемы требуется хранить (и
делать это эффективно!) информацию о том, из какого заголовочного файла (цепочки
файлов) лексема попала в текущую единицу трансляции, и если она была получена в
результате подстановки макроса, то хранится также цепочка макросов. Если это
объяснение покажется немного путанным, возможно примеры `include.c` и `macro.c`
прояснят что именно подразумевается под "цепочкой файлов" и "цепочкой макросов".

Обратите внимание на комментарии в файле `libcpp/include/line-map.h` (они
довольно подробные) и `libcpp/location-example.txt`.

## Имеющиеся патчи по диагностическим сообщениям

Сейчас Дэвид Мэлколм (David Malcolm) работает над
[серией патчей](https://gcc.gnu.org/ml/gcc-patches/2015-10/msg02536.html), относящихся к
диагностике ([обсуждение целиком](https://gcc.gnu.org/ml/gcc-patches/2015-10/threads.html#02536)).
Стоит ознакомиться с их обсуждением (см. ссылку). Мы будем работать поверх этой серии,
т.к. большая часть патчей уже была одобрена и велика вероятность того, что они в
итоге войдут в релиз.
На будущее: скачайте и примените эти патчи к своему "дереву" GCC. Соберите GCC и
посмотрите как стали выглядеть диагностические сообщения на наших примерах

Примечание: возможно также стоит кратко проглядеть историю создания этих патчей
([версия 1](https://gcc.gnu.org/ml/gcc-patches/2015-09/threads.html#00726),
[версия 2](https://gcc.gnu.org/ml/gcc-patches/2015-09/threads.html#01696);
текущая "версия 5" следует за версией 2 :) исходя из максимальной версии
отдельного патча).

## Задание №1

Придумать формат диагностических сообщений. Как минимум он должен учитывать следующие сущности:
- Файлы (с исходным кодом программы)
- Позиции с файле (строка, столбец)
- Типы сообщений: предупреждения и ошибки.
- Опции, контролирующие предупреждения

В формате должно быть учтено следующее:
- Один файл может включать другие файлы (механизм include). Вложенность - 
  произвольная
- Одна ошибка может содержать несколько сущностей. Например, "constexpr-вызов в 
  параметре шаблона, развёрнутого из макроса".
- Редактор кода не обязан "знать", что такое шаблон или макрос, (т.е. различать 
  сущности между собой), но важно что в одной ошибке их может быть несколько, у 
  каждой сущности  есть позиция и к каждой из них компилятор может вывести 
  примачение "notice")
- Компилятор может предложить вариант исправления ошибки
- Позиция ошибки в файле может быть как "точкой" (т.е. один конкретный символ в 
  файле), так и диапазоном (“отрезком”).
- Подумайте, какие могут быть способы расширения формата с минимальной “болью” 
  как для компилятора так и для IDE. Как IDE смогут распознавать версию формата? 
  Смогут ли они отбросить “непонятные” элементы и показать “понятные”?
 - Пример "расширения". См. файл `printf.c`. Допустим, что в следующей версии 
   GCC сможет "подсвечивать" несовпавшую пару: символ форматной строки (`%f`) и 
   соответствующий аргумент функции `printf` (число `1`). Как можно будет изменить 
   формат так, чтобы старые редакторы смогли вывести осмысленное сообщение об 
   ошибке, а новые версии редакторов распознали новую сущность "пара позиций в 
   файле"?