# Сборка проекта

## Системы сборки

Часто IDE (такие как Visual Studio или Eclipse) имеют встроенные средства для
сборки проекта. К сожалению пользоваться ими удобно далеко не во всех случаях.
Как минимум: * при совместной работе над одним проектом каждому разработчику
удобнее иметь собственные настройки IDE (к тому же, у разные участники проекта
могут пользоваться разными IDE), при этом настройки сборки проекта должны всё же
находиться в общем репозитории вместе с исходным кодом * при распространении
программы в форме исходного кода не следует заставлять пользователя
устанавливать на свой компьютер IDE, если для сборки проекта достаточно лишь
компилятора и системы сборки * сборка и тестирование программы на сервере
непрерывной интеграции должны происходить автоматически, т.е. запускаться из
командной строки Поэтому даже если вы используете для разработки IDE, стоит всё
же использовать для сборки проекта специально предназначенный для этого
инструмент. Альтернативный вариант --- использовать для сборки проекта набор
shell-скриптов (или batch-файлов Windows), но у такого подхода есть существенные
недостатки: * в разных операционных системах используются разные оболочки,
поэтому для каждой ОС придётся писать свой набор скриптов * процессе разработки
целесообразно использовать инкрементальную сборку (т.е. пересобирать только
изменившуюся часть проекта). Реализовать подобный режим в shell-скрипте будет
нетривиально. Поэтому стоит всё же использовать для сборки проекта специально
предназначенный для этого инструмент. Существует несколько подобных систем. Одна
из самых популярных --- программа make и её варианты (например, GNU make,
используемый по умолчанию в Linux). В дополнение к make существуют надстройки,
такие как autoconf (входящий в состав
[autotools](https://www.sourceware.org/autobook)), упрощающие портирование
программ под различные платформы. Более современная и удобная альтернатива
autoconf - программа [CMake](https://cmake.org), которую мы рассмотрим
подробнее. На github имеется отличная подборка ссылок [Awesome
CMake](https://github.com/onqtam/awesome-cmake), включающая в себя руководства,
примеры скриптов и модули.

### Использование CMake

Основная задача CMake --- это сборка проекта, но помимо этого CMake также удобно
использовать для запуска тестов. Чтобы собрать проект с помощью CMake,
необходимо описать шаги сборки в специально файле.

По сути, такое описание --- это граф, вершинами которого являются исходные,
промежуточные и результирующие файлы проекта (иногда множества файлов), а рёбра ---
действия, которые необходимо предпринять, чтобы создать промежуточные и
результирующие файлы. Сборка проекта представляет собой обход такого графа в
топологическом порядке. Очень важным здесь является то, что сборка проекта
описывается декларативно, а не императивно, т.е. описание не подразумевает
какого-либо определённого порядка для не зависящих друг от друга шагов сборки.
За счёт этого на многоядерной машине несколько шагов могут выполняться
параллельно.

CMake, используя описание, подготавливает сборку для той машины, на которой он
был запущен: определяет установленный в системе компилятор, необходимые для него
ключи командной строки, проверяет наличие необходимых библиотек и пути к ним и
т.д. Результатом работы программы `cmake` является make-файл для используемой на
данной платформе системы сборки (например, Makefile для GNU make в Linux, либо
файл проекта Visual Studio в Windows; [полный
список](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html)
поддерживаемых систем сборки представлен в документации). По сгенерированному
файл осуществляется собственно сборка проекта.

#### Файл проекта и основные команды

По соглашению, основной файл проекта CMake называется `CMakeLists.txt`. Это файл
содержит команды
([список](https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html)
которых довольно обширен). Синтаксис команд довольно прост: вначале пишется имя
команды, затем в скобках перечисляются её аргументы. Аргументы отделяются друг
от друга пробелами. Перед значением аргумента может следовать его название.

Рассмотрим некоторые команды.

Команда [project](https://cmake.org/cmake/help/latest/command/project.html)
задаёт название проекта, его версию и используемые языки программирование
(исходя из списка языков CMake будет осуществлять поиск компиляторов). Пример:

```
project(my_project CXX)
```

(CXX здесь обозначает язык C++). Либо:

```
project(my_project VERSION 1.0.0 LANGUAGES CXX)
```

Команда
[add_executable](https://cmake.org/cmake/help/latest/command/add_executable.html)
добавляет к сборке исполняемый файл, компилируемый из заданного списка исходных
файлов. Например:

```
add_executable(my_program main.cpp input.cpp output.cpp)
```

Похожим образом, но с помощью команды
[add_library](https://cmake.org/cmake/help/latest/command/add_library.html)
описывается сборка библиотеки:

```
add_library(my_shared_lib SHARED libsrc.cpp)
```

Библиотека `my_shared_lib` будет собрана как динамически загружаемая (shared
object), это означает для запуска использующей библиотеку программы, библиотека
должна быть установлена в системе. При этом один экземпляр библиотеки может
использоваться несколькими разными программами. Альтернативным вариантом
являются статические библиотеки. В процессе компоновки их код записывается
непосредственно в исполняемый файл программы, поэтому установка библиотеки не
требуется, но возможность использования одного экземпляра библиотеки несколькими
разными программами теряется. Статические библиотеки описываются так:

```
add_library(my_static_lib STATIC libsrc.cpp)
```

Команда
[target_link_libraries](https://cmake.org/cmake/help/latest/command/target_link_libraries.html)
позволяет скомпоновать исполняемый файл с библиотекой (либо две библиотеки между
собой):

```
target_link_libraries(my_program my_static_lib)
```

Команда
[include_directories](https://cmake.org/cmake/help/latest/command/include_directories.html)
позволяет задать пути к заголовочным файлам. Пути задаются относительно
директории с файлом `CMakeLists.txt`:

```
include_directories(src include)
```

Эта команда добавляет две директории, в которых будет осуществляться поиск
заголовочных файлов: `./src` и `./include`.

#### Возможности языка CMake

Язык описания файлов проекта --- это полноценный язык программирования. К
примеру, мы можете использовать переменные для хранения нужных вам значений:

```
set(SOURCES input.cpp output.cpp)
add_executable(my_program main.cpp ${SOURCES})
```

Значение переменной задаётся с помощью команды
[set](https://cmake.org/cmake/help/latest/command/set.html), а считывается при
помощи конструкции `${VARIABLE}` (`VARIABLE` - название переменной).

При помощи команд [if](https://cmake.org/cmake/help/latest/command/if.html),
`else`, `elseif` и `endif` осуществляется ветвление:

```
if (${CMAKE_HOST_WIN32})
    add_executable(win_program main.cpp)
endif()
```

В этом примере программа `win_program` будет компилироваться только если сборка
запущена из операционной системы Windows. `CMAKE_HOST_WIN32` --- это встроенная
переменная CMake. Имеется и множество других [встроенных
переменных](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html),
описывающих систему, на которой выполняется сборка, а также влияющих на сам
процесс сборки.

В языке CMake имеются и другие привычные синтаксические конструкции:
математический операции, циклы, функции. Команды CMake позволяют работать со
строками, списками, с файловой системой и другими объектами. Подробно они
описаны в [документации по
командам](https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html).

#### Запуск CMake

CMake запускается из директории, в которой будет происходить сборка, т.е. в ней
в итоге окажутся результат сборки и промежуточные файли. Она может совпадать с
директорией проекта, но удобнее всё же собирать проект в отдельной директории.
Это позволит легко удалить все промежуточные файли, если вам захочется собрать
проект "с нуля", а также избавит от необходимости настраивать исключения для
системы контроля версий (`.gitignore`).

Итак, допустим, мы создали внутри директории проекта поддиректории `build` и
`build/debug`:

```
mkdir -p build/debug
```

Для выполнения сборки следует перейти в эту директорию и запустить CMake:

```
cd build/debug
cmake ../.. -DCMAKE_BUILD_TYPE=Debug
```

В качестве первого аргумента указывается путь к исходному коду (т.е. директории
с файлом `CMakeLists.txt`). Далее, мы с помощью ключа `-D` определили значение
переменной `CMAKE_BUILD_TYPE` как `Debug`. Это означает, что проект будет
собираться в конфигурации для отладки (по умолчанию это означает: включить
генерацию отладочной информации и отключать оптимизацию).

Затем из этой же директории запускаем make:

```
make -j8
```

В качестве параметра `-j` указывается количество параллельных потоков сборки.
Как правило, следует указать количество ядер процессора (с учётом
hyperthreading). В скриптах для сборки часто используют команду `nproc`, с
помощью которой можно определить количество ядер:

```
make -j$(nproc)
```

Аналогичным образом собирается проект в конфигурации `Release`. Конфигурация по
умолчанию не очень полезна, т.к. в ней отключена как отладочная информация, так
и оптимизация.
