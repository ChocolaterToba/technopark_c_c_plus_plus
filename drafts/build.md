# Сборка проекта

## Запуск компилятора

Компилятор GCC предоставляет множество опций командной строки. Полезно будет
ознакомиться с основными из них. Заметим что Clang во многом совместим с GCC и
описанные здесь основные опции работают и с Clang-ом (если явно не сказано обратное).

Список всех опций и их описание можно прочитать на
[сайте GCC](https://gcc.gnu.org/onlinedocs/).

### Функции компилятора

Программа `gcc` (а также `g++`) - это так называемый драйвер компилятора, т.е.
обёртка, служащая для запуска других программ - компилятора в узком смысле
(программы, "переводящей" другие программы с языка высокого уровня на язык
ассемблера), ассемблера и компоновщика. По умолчанию `g++` запускает все три
программы (компилятор, ассемблер и компоновщик) последовательно. Таким образом,
исполнение

    g++ test.cpp

создаст сразу исполняемый файл с программой, исходный текст которой взят из
файла `test.cpp`. Имя выходного файла по умолчанию - `a.out`. Для того чтобы
задать произвольное имя выходного файла используется ключ `-o`:

    g++ test.cpp -o test

Порядок ключей и имён файлов в большинстве случаев произвольный, т.е. ту же
самую команду можно записать как

    g++ -o test test.cpp

Для того чтобы получить файл с объектным кодом (т.е. пропустить программу
последовательно через компилятор и ассемблер) служит ключ `-c`:

    g++ -c test.cpp -o test.o

Если же требуется получить файл на языке ассемблера, следует использовать ключ
`-S`:

    g++ -S test.cpp -o test.s

Скомпоновать несколько объектных файлов в один исполняемый можно следующим
образом:

    g++ file1.o file2.o -o myprogram

При компоновке важно использовать правильный драйвер: `g++` для программ,
написанных на языке C++ и `gcc` для программ на языке C. От выбора драйвера
зависит набор стандартных библиотек, который будет по умолчанию подключен к
программе.

### Выбор языка и стандарта

Язык программы (C либо C++) определяется драйвером исходя из расширения файла и
не зависит от того, какой драйвер (`gcc` или `g++` используется для компиляции).
При необходимости язык можно задать явно (с помощью опции `-x`), но лучше,
разумеется, пользоваться общепринятыми расширениями файлов: `.c` для программ
на языке C и `.cpp` (или `.cc`) для языка C++.

Компилятор GCC поддерживает несколько стандартов языков C и C++ различающихся
набором доступных возможностей языка. Версия стандарта задаётся при помощи ключа
`-std=`, например:

    g++ -c test.cpp -std=c++14

задаёт стандарт C++14. GCC поддерживает некоторые расширения языков C и C++ (их
[список](https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html) весьма
внушительный). Чтобы разрешить их использование, используются обозначение
стандарта в котором `c` заменяется на `gnu` (а `c++` на `gnu++`). Например:

    gcc -c test.c -std=gnu11

запускает компиляцию с использованием стандарта C11 с включенными расширениями.

### Пути к заголовочным файлам и макроопределния

Если вы используете в программе директиву препроцессора вида
`#include <header.hpp>`, компилятор должен каким-то образом найти в файловой
системе заголовочный файл `header.hpp`. По умолчанию, GCC ищет файлы в
системных путях, заданных ещё в процессе сборки самого компилятора, таких как
`/usr/include`. Часто требуется добавить к ним дополнительные пути к исползуемым
библиотекам. Для этого служит опция командной строки `-I`. Например:

    g++ -c file.cpp -Ithird-party/include -Iinclude

добавляет к списку путей директории `third-party/include` и `include` (которые
должны находиться в текущей директории).

Напомним, что при использовании директивы `#include` с кавычками, т.е.
`#include "header.hpp"` для поиска также используется директория, в которой
находится компилируемый файл.

В некоторых случаях поведением программы удобно урпавлять с помощью макросов.
Например, библиотека glibc определяет макрос `assert`, поведение которого
изменяется в зависимости от того, определён ли макрос `NDEBUG`. А именно, если
`NDEBUG` определён, то `assert` никак не влияет на поведение программы. Если
же он не определён, то `assert` проверяет, истинно ли значение, переданное ему
в качестве аргумента, и если оно ложно, программа аварийно завершается. Такое
поведение полезно при отладке, но в дистрибутиве программы, передаваемой
пользователю, лишние проверки нежелательны, т.к. отрицательно сказываются на
производительности программы. Поэтому при компиляции выпускаемой версии
программы определяют макрос NDEBUG:

    g++ -c program.cpp -DNDEBUG

Опция `-D` опредяет макрос `NDEBUG` так, как если бы в первой строке программы
была директива

```C++
#define NDEBUG
```

С помощью опции `-D` можно также задать значение определяемого макроса:

    g++ -c program.cpp -DVERSION="1.1"

эквивалентно добавлению строки

```C++
#define VERSION "1.1"
```

в начало компилируемого файла.

### Опции, влияющие на программы с неопределённым поведением

Отличительной чертой языков С и C++ является т.н. "неопределённое поведение":
стандарты этих языков подразумевают, что программист позаботится о том, чтобы в
программе отсутствовали некоторые виды поведения, например, обращение к
неинициализированным переменным. Компилятор, в свою очередь, может полагаться на
это, поскольку стандарт не предъявляет к компилятору никаких требований
относительно того, какой именно код должен сгенерировать компилятор при наличии
в программе неопределённого поведения. Такое соглашение между авторами
стандарта, авторами компилятора и программистами позволяет во многих случаях
генерировать код с максимальным быстродействием. В то же время, обеспечить
отсутствие в программе некоторых видов неопределённого поведения трудно, а
задача проверки кода на отстуствие неопределённого поведения алгоритмически
неразрешима. Поэтому авторы компилятора GCC добавили несколько опций, которые
позволяют "доопределить" стандарты языков C и C++, придав некоторым случаям
неопределённого поведения вполне конкретную семантику.

В частности, опция `-fwrapv` определяет, что арифметические операции над целыми
числами со знаком должны выполняться с циклическим переполнением. К примеру,
согласно стандарту C++, в следующем примере

```
int x;
// ...
if (x + 1 > x) {
    // ...
}
```

переполнение при вычислении `x + 1` является неопределённым поведением, поэтому
компилятор может предположить, что этого никогда не произойдёт, а условие `x + 1 >
x` всегда истинно и удалить код, отвечающий за проверку этого условия. Однако,
если задать опцию `-fwrapv` компилятор будет основываться на том, что
переполнение циклическое, поэтому `x + 1` может быть отрицательным (например,
при 32-битном `int`, `0x7FFFFFFF + 1` равно `0x80000000` или `-2147483648`) и не
будет удалять проверку.

Ещё одно проблематичное для многих правила языков C и C++ --- это правило о
строгом соответствии псевдонимов (strict aliasing) и связанная с ним оптимизация ---
анализ псевдонимов, основанный на типах (type based alias analysis). Согласно
стандартам языков C и C++, через указатель на тип `T` допускается получать
доступ только к значениям типа `T`. Исключение составляют указатели на
символьный тип (`char`, `signed char` и `unsigned char`), т.к. через них можно
считывать значения других типов. Например, следующий код не вызывает
неопределённого поведения:

```
int x = 5;
const char* p = (char *)&x;
return *p;
```

а вот этот пример --- вызывает:

```
double x = 1.0;
return *(int *)(&x);
```

За счёт данного правила компилятор может в следующем фрагменте кода

```
int foo(int* x, double* y)
{
    y[0] = x[0];
    return x[0];
}
```

считать, что присваивание `y[0] = x[0]` не меняет значения `x[0]` (поскольку
указатели `x` и `y` различаются) и выполнить одну операцию чтения из памяти
вместо двух.

Ключ `-fno-strict-aliasing` отключает данный вид анализа, т.е. заставляет
компилятор предполагать, что любые два указателя могут быть псевдонимами друг
друга, если обратное не следует, например, из правил адресной арифметики.

### Предупреждения

Предупреждения компилятора сообщают программисту о найденных в программе
потенциальных проблемах - конструкциях, хотя и разрешённых стандартом языка, но
могут свидетельствовать о наличии в программе ошибки.

Рассмотрим такой пример:

* TODO: ПРИМЕР

Большинство предупреждений имеют отдельный ключ командандной строки, который
отвечает только за данное предупреждение. Также существуют ключи, активирующие
сразу целую группу предупреждений.

Так, предупреждения, которые с высокой вероятностью вызваны ошибкой в программе
активируются опцией `-Wall`. Предупреждения, активируемые опцией `-Wextra`,
могут в некоторых случаях вызывать ложно-положительные срабатывания, но в
большинстве случаях также полезны. Рекомендуется использовать как `-Wall`, так и
`-Wextra` в своих проектах.

Наконец,
[предупреждения](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options),
не включенные ни в одну из этих групп могут быть полезны в зависимости от
стандартов кодирования, применямых в конкретном проекте. Например, разработчики
проекта могут договориться о том, чтобы всегда помечать перекрываемые
виртуальные методы с помощью ключевого слова `override`. В этом случае полезно
будет задействовать опцию `-Wsuggest-override` (данная опция присутствует только
в GCC начиная с версии 5), чтобы компилятор выдывал предупреждение о виртуальных
методах, в объявлении которых ключевое слово `override` отсутствует.

### Оптимизации компилятора

Оптимизатор присутствует в большинстве современных компиляторов С и C++, таких
как GCC, Clang и MSVC. Функция оптимизатора заключается в том, чтобы
преобразовать исходную программу в эквивалентную ей семантически, но работающую
быстрее. Оптимизатор GCC организован в виде конвеера, состоящего из т.н.
проходов. Каждый проход выполняет некоторый вид преобразований программы,
представленной в виде промежуточного представления. Это представление
последовательно подаётся на активные проходы (этапы конвеера). Как и
предпреждения, оптимизации объединены в группы, активируемые различными ключами
командной строки. Так, ключ `-O1` (либо `-O`) включает наиболее простые и быстро
выполняемые оптимизации, `-O2` выполняет также и более "дорогие" оптимизации.
Наконец, в `-O3` входят сложные оптимизации, порой имеющие квадратичное (по
количеству кода в отдельной функции программы) время работы. Ключ `-Os`
настраивает оптимизатор так, чтобы генерировать код меньшего размера (иногда в
ущерб быстродействию). Такой режим полезен при компиляции программ,
предназначенных для встраиваемых систем (например, микроконтроллеров).

Чтобы получить общее представление о том, как работает оптимизатор, рассмотрим в
качестве примера один из проходов оптимизатора --- встраивание функций
(inlining). Встраивание выполняет подстановку тела функции в место её вызова.
Например, такой код:

```
int add2(int x)
{
    return x + x;
}

int add3(int x)
{
    return x + add2(x);
}
```

Можно преобразовать в эквивалентный:

```
int add2(int x)
{
    return x + x;
}

int add3(int x)
{
    return x + x + x;
}
```

тем самым сэкономив в функции `add3` время на копировании аргументов функции
`add2`, её вызове и возврате из функции. Повторимся: оптимизатор работает с
промежуточным представлением программы, а не с исходным кодом, поэтому данный
пример, разумеется, условный. Кроме того, встраивание на самом деле пытается
скопировать код функции без изменений, т.е. результат будет больше похож на

```
int add3(int x)
{
    int __add2_x = x;
    int __add2_result = __add2_x + __add2_x;
    return x + __add2_result;
}
```

От лишних операций копирования помогут избавиться последующие этапы конвеера:
проход распространения констант и копий (constant and copy propagation), а также
проход устранения мёртвого кода (dead code elimination). Как видно из этого
примера, выполнение одной оптимизации может предоставить возможность выполнить
другие, поэтому конвеер оптимизатор устроен достаточно сложно: некоторые проходы
выполняются несколько раз, а их порядок тщательно выверен.

Оптимизация позволяет значительно увеличить производительность программы:
зачастую оптимизированный код выполняется в 1,5-3 раза быстрее
неоптимизированного. Разумеется оптимизации не бесплатны: компиляция программы с
включённой оптимизацией выполняется медленнее. Ещё один недостаток
оптимизированного кода --- меньшее удобство в отладке (например, в отладчике
может быть недоступен просмотр значений некоторых переменных). Частично этот
недостаток устраняется опцией `-Og` (доступна только в GCC): она выключает те
проходы оптимизатора, которые отрицательно сказываются на качестве отладочной
информации. Производительность кода с этой опцией примерно соответствует
производительности `-O1`.

### Отладочная информация

Как уже отмечалось в статьях о GDB и Valgrind, отладочная информация содержит
соответствия между элементами бинарного кода (адреса, регистры процессора) и
исходного кода (номера строк, имена функций и переменных) программы. Запись
отладочной информации в генерируемые компилятором файлы включается с помощью
ключа `-g`. Ключ `-ggdb3` включает вывод дополнительной информаций, специфичной
для отладчика GDB. Подробнее об отладке можно прочитать в статье [Отладка
программ с помощью GDB](gdb-intro.md).

## Системы сборки

Часто IDE (такие как Visual Studio или Eclipse) имеют встроенные средства для
сборки проекта. К сожалению пользоваться ими удобно далеко не во всех случаях.
Как минимум: * при совместной работе над одним проектом каждому разработчику
удобнее иметь собственные настройки IDE (к тому же, у разные участники проекта
могут пользоваться разными IDE), при этом настройки сборки проекта должны всё же
находиться в общем репозитории вместе с исходным кодом * при распространении
программы в форме исходного кода не следует заставлять пользователя
устанавливать на свой компьютер IDE, если для сборки проекта достаточно лишь
компилятора и системы сборки * сборка и тестирование программы на сервере
непрерывной интеграции должны происходить автоматически, т.е. запускаться из
командной строки Поэтому даже если вы используете для разработки IDE, стоит всё
же использовать для сборки проекта специально предназначенный для этого
инструмент. Альтернативный вариант --- использовать для сборки проекта набор
shell-скриптов (или batch-файлов Windows), но у такого подхода есть существенные
недостатки: * в разных операционных системах используются разные оболочки,
поэтому для каждой ОС придётся писать свой набор скриптов * процессе разработки
целесообразно использовать инкрементальную сборку (т.е. пересобирать только
изменившуюся часть проекта). Реализовать подобный режим в shell-скрипте будет
нетривиально. Поэтому стоит всё же использовать для сборки проекта специально
предназначенный для этого инструмент. Существует несколько подобных систем. Одна
из самых популярных --- программа make и её варианты (например, GNU make,
используемый по умолчанию в Linux). В дополнение к make существуют надстройки,
такие как autoconf (входящий в состав
[autotools](https://www.sourceware.org/autobook)), упрощающие портирование
программ под различные платформы. Более современная и удобная альтернатива
autoconf - программа [CMake](https://cmake.org), которую мы рассмотрим
подробнее. На github имеется отличная подборка ссылок [Awesome
CMake](https://github.com/onqtam/awesome-cmake), включающая в себя руководства,
примеры скриптов и модули.

### Использование CMake

Основная задача CMake --- это сборка проекта, но помимо этого CMake также удобно
использовать для запуска тестов. Чтобы собрать проект с помощью CMake,
необходимо описать шаги сборки в специально файле.

По сути, такое описание --- это граф, вершинами которого являются исходные,
промежуточные и результирующие файлы проекта (иногда множества файлов), а рёбра ---
действия, которые необходимо предпринять, чтобы создать промежуточные и
результирующие файлы. Сборка проекта представляет собой обход такого графа в
топологическом порядке. Очень важным здесь является то, что сборка проекта
описывается декларативно, а не императивно, т.е. описание не подразумевает
какого-либо определённого порядка для не зависящих друг от друга шагов сборки.
За счёт этого на многоядерной машине несколько шагов могут выполняться
параллельно.

CMake, используя описание, подготавливает сборку для той машины, на которой он
был запущен: определяет установленный в системе компилятор, необходимые для него
ключи командной строки, проверяет наличие необходимых библиотек и пути к ним и
т.д. Результатом работы программы `cmake` является make-файл для используемой на
данной платформе системы сборки (например, Makefile для GNU make в Linux, либо
файл проекта Visual Studio в Windows; [полный
список](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html)
поддерживаемых систем сборки представлен в документации). По сгенерированному
файл осуществляется собственно сборка проекта.

#### Файл проекта и основные команды

По соглашению, основной файл проекта CMake называется `CMakeLists.txt`. Это файл
содержит команды
([список](https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html)
которых довольно обширен). Синтаксис команд довольно прост: вначале пишется имя
команды, затем в скобках перечисляются её аргументы. Аргументы отделяются друг
от друга пробелами. Перед значением аргумента может следовать его название.

Рассмотрим некоторые команды.

Команда [project](https://cmake.org/cmake/help/latest/command/project.html)
задаёт название проекта, его версию и используемые языки программирование
(исходя из списка языков CMake будет осуществлять поиск компиляторов). Пример:

```
project(my_project CXX)
```

(CXX здесь обозначает язык C++). Либо:

```
project(my_project VERSION 1.0.0 LANGUAGES CXX)
```

Команда
[add_executable](https://cmake.org/cmake/help/latest/command/add_executable.html)
добавляет к сборке исполняемый файл, компилируемый из заданного списка исходных
файлов. Например:

```
add_executable(my_program main.cpp input.cpp output.cpp)
```

Похожим образом, но с помощью команды
[add_library](https://cmake.org/cmake/help/latest/command/add_library.html)
описывается сборка библиотеки:

```
add_library(my_shared_lib SHARED libsrc.cpp)
```

Библиотека `my_shared_lib` будет собрана как динамически загружаемая (shared
object), это означает для запуска использующей библиотеку программы, библиотека
должна быть установлена в системе. При этом один экземпляр библиотеки может
использоваться несколькими разными программами. Альтернативным вариантом
являются статические библиотеки. В процессе компоновки их код записывается
непосредственно в исполняемый файл программы, поэтому установка библиотеки не
требуется, но возможность использования одного экземпляра библиотеки несколькими
разными программами теряется. Статические библиотеки описываются так:

```
add_library(my_static_lib STATIC libsrc.cpp)
```

Команда
[target_link_libraries](https://cmake.org/cmake/help/latest/command/target_link_libraries.html)
позволяет скомпоновать исполняемый файл с библиотекой (либо две библиотеки между
собой):

```
target_link_libraries(my_program my_static_lib)
```

Команда
[include_directories](https://cmake.org/cmake/help/latest/command/include_directories.html)
позволяет задать пути к заголовочным файлам. Пути задаются относительно
директории с файлом `CMakeLists.txt`:

```
include_directories(src include)
```

Эта команда добавляет две директории, в которых будет осуществляться поиск
заголовочных файлов: `./src` и `./include`.

#### Возможности языка CMake

Язык описания файлов проекта --- это полноценный язык программирования. К
примеру, мы можете использовать переменные для хранения нужных вам значений:

```
set(SOURCES input.cpp output.cpp)
add_executable(my_program main.cpp ${SOURCES})
```

Значение переменной задаётся с помощью команды
[set](https://cmake.org/cmake/help/latest/command/set.html), а считывается при
помощи конструкции `${VARIABLE}` (`VARIABLE` - название переменной).

При помощи команд [if](https://cmake.org/cmake/help/latest/command/if.html),
`else`, `elseif` и `endif` осуществляется ветвление:

```
if (${CMAKE_HOST_WIN32})
    add_executable(win_program main.cpp)
endif()
```

В этом примере программа `win_program` будет компилироваться только если сборка
запущена из операционной системы Windows. `CMAKE_HOST_WIN32` --- это встроенная
переменная CMake. Имеется и множество других [встроенных
переменных](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html),
описывающих систему, на которой выполняется сборка, а также влияющих на сам
процесс сборки.

В языке CMake имеются и другие привычные синтаксические конструкции:
математический операции, циклы, функции. Команды CMake позволяют работать со
строками, списками, с файловой системой и другими объектами. Подробно они
описаны в [документации по
командам](https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html).

#### Запуск CMake

CMake запускается из директории, в которой будет происходить сборка, т.е. в ней
в итоге окажутся результат сборки и промежуточные файли. Она может совпадать с
директорией проекта, но удобнее всё же собирать проект в отдельной директории.
Это позволит легко удалить все промежуточные файли, если вам захочется собрать
проект "с нуля", а также избавит от необходимости настраивать исключения для
системы контроля версий (`.gitignore`).

Итак, допустим, мы создали внутри директории проекта поддиректории `build` и
`build/debug`:

```
mkdir -p build/debug
```

Для выполнения сборки следует перейти в эту директорию и запустить CMake:

```
cd build/debug
cmake ../.. -DCMAKE_BUILD_TYPE=Debug
```

В качестве первого аргумента указывается путь к исходному коду (т.е. директории
с файлом `CMakeLists.txt`). Далее, мы с помощью ключа `-D` определили значение
переменной `CMAKE_BUILD_TYPE` как `Debug`. Это означает, что проект будет
собираться в конфигурации для отладки (по умолчанию это означает: включить
генерацию отладочной информации и отключать оптимизацию).

Затем из этой же директории запускаем make:

```
make -j8
```

В качестве параметра `-j` указывается количество параллельных потоков сборки.
Как правило, следует указать количество ядер процессора (с учётом
hyperthreading). В скриптах для сборки часто используют команду `nproc`, с
помощью которой можно определить количество ядер:

```
make -j$(nproc)
```

Аналогичным образом собирается проект в конфигурации `Release`. Конфигурация по
умолчанию не очень полезна, т.к. в ней отключена как отладочная информация, так
и оптимизация.
